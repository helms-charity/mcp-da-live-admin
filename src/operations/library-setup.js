// src/operations/library-setup.js

import { z } from 'zod';
import { resolveBlockSource } from '../common/block-utils.js';
import { daAdminRequest, formatURL, uploadHTML, uploadJSON } from '../common/utils.js';
import {
  buildLibraryPath,
  buildContentUrl,
  getDataSheet,
  getOptionsSheet,
  createLibraryJSON,
  addEntry
} from '../common/library-cfg-utils.js';
import { validateDADestination } from '../common/validation-utils.js';
import { generateBlockTemplate, extractBlockContent, analyzeBlock } from './blocks.js';
import { LIBRARY_TYPES } from '../common/global.js';
import { registerLibraryType } from './config.js';

const AddBlockSchema = z.object({
  org: z.string().describe('DA organization (destination for documentation)'),
  repo: z.string().describe('DA repository (destination for documentation)'),
  blockName: z.string().describe('The block name to add'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  github: z.object({
    org: z.string(),
    repo: z.string(),
    branch: z.string().optional().default('main'),
    blocksPath: z.string().optional().default('blocks')
  }).optional().describe('ONLY provide if explicitly fetching from a different GitHub repo (repoless setup). Omit to auto-detect local blocks.'),
  useLocal: z.boolean().optional().describe('Explicitly use local file system. Omit to auto-detect.'),
  localBlocksPath: z.string().optional().describe('Custom path to local blocks directory. Omit to use ./blocks'),
  description: z.string().optional().describe('Optional description for Library Metadata'),
  sourceDocuments: z.array(z.string()).optional().describe('Optional array of source document paths. Use "/" or "index" for homepage (searches in order)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

const SetupSchema = z.object({
  org: z.string().describe('DA organization (destination for documentation)'),
  repo: z.string().describe('DA repository (destination for documentation)'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  github: z.object({
    org: z.string(),
    repo: z.string(),
    branch: z.string().optional().default('main'),
    blocksPath: z.string().optional().default('blocks')
  }).optional().describe('ONLY provide if explicitly fetching from a different GitHub repo (repoless setup). Omit to auto-detect local blocks.'),
  useLocal: z.boolean().optional().describe('Explicitly use local file system. Omit to auto-detect.'),
  localBlocksPath: z.string().optional().describe('Custom path to local blocks directory. Omit to use ./blocks'),
  filter: z.string().optional().describe('Optional regex pattern to filter block names'),
  sourceDocuments: z.array(z.string()).optional().describe('Optional array of source document paths. Use "/" or "index" for homepage (searches in order for each block)'),
  autoGenerateDocs: z.boolean().optional().default(true).describe('Automatically generate documentation for blocks (default: true)'),
  preserveExisting: z.boolean().optional().default(true).describe('Preserve existing documentation (default: true)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

function buildBlockFilePath(blockName, fileName) {
  return `${blockName}/${fileName}`;
}

function normalizeSourceDocuments(sourceDocuments) {
  if (!sourceDocuments || sourceDocuments.length === 0) {
    return null;
  }
  
  return sourceDocuments.map(path => {
    if (!path || path === '/' || path === '' || path === 'index' || path === 'home') {
      return '/index';
    }
    return path;
  });
}

function createBlockEntry(blockName, baseFolder, org, repo) {
  const displayName = blockName.charAt(0).toUpperCase() + blockName.slice(1);
  const blockPath = buildContentUrl(org, repo, `${baseFolder}/blocks/${blockName}`);
  return { name: displayName, path: blockPath };
}

async function uploadHTMLContent(org, repo, path, htmlContent) {
  const url = formatURL('source', org, repo, path, 'html');
  return uploadHTML(url, htmlContent);
}

async function uploadJSONContent(org, repo, path, jsonData) {
  const url = formatURL('source', org, repo, path, 'json');
  return uploadJSON(url, jsonData);
}


async function createBlockDoc(org, repo, docPath, blockName, variants, description, blockContent = null) {
  const template = generateBlockTemplate(blockName, description, variants, {}, blockContent);
  await uploadHTMLContent(org, repo, docPath, template);
  return buildContentUrl(org, repo, docPath);
}

async function checkBlockFiles(source, blockName) {
  const files = await source.listFiles(blockName);
  return files.filter(f => f.endsWith('.js') || f.endsWith('.css'));
}

async function checkDocExists(org, repo, docPath) {
  try {
    const url = formatURL('source', org, repo, docPath, 'html');
    await daAdminRequest(url);
    return true;
  } catch {
    return false;
  }
}

async function getExistingBlocksConfig(org, repo, baseFolder) {
  try {
    const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
    const url = formatURL('source', org, repo, configPath, 'json');
    return await daAdminRequest(url);
  } catch {
    return null;
  }
}

async function updateBlocksConfig(org, repo, baseFolder, entries) {
  const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
  const blocksJSON = await getExistingBlocksConfig(org, repo, baseFolder);

  let dataSheet = getDataSheet(blocksJSON);
  const optionsSheet = getOptionsSheet(blocksJSON);

  for (const entry of entries) {
    dataSheet = addEntry(dataSheet, entry);
  }

  const newBlocksJSON = createLibraryJSON(LIBRARY_TYPES.BLOCKS, dataSheet.data, optionsSheet);
  await uploadJSONContent(org, repo, configPath, newBlocksJSON);

  return {
    configPath,
    optionsPreserved: !!optionsSheet
  };
}

async function processBlockDocumentation(source, org, repo, blockName, baseFolder, description, sourceDocuments, docExists, preview) {
  if (docExists) {
    return {
      step: 4,
      action: 'Preserving existing documentation',
      status: 'completed',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      created: false
    };
  }

  if (preview) {
    return {
      step: 4,
      action: 'Would create documentation',
      status: 'planned',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      sourceDocuments: sourceDocuments || null
    };
  }

  const analysis = await analyzeBlock(source, blockName);
  const finalDescription = description || analysis.description;
  const { content: blockContent, sourceUsed } = await extractBlockContent(org, repo, sourceDocuments, blockName);
  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = await createBlockDoc(org, repo, docPath, blockName, analysis.variants, finalDescription, blockContent);

  return {
    step: 4,
    action: 'Creating block documentation',
    status: 'completed',
    created: true,
    docPath,
    docUrl,
    usedSourceContent: !!blockContent,
    sourceUsed: sourceUsed || null
  };
}

async function addBlock(args) {
  const { org, repo, blockName, baseFolder, description, sourceDocuments, preview } = args;
  const sources = normalizeSourceDocuments(sourceDocuments);

  const result = {
    blockName,
    baseFolder,
    preview,
    steps: [],
    errors: []
  };

  try {
    result.steps.push({ step: 1, action: 'Validating destination and resolving source', status: 'in_progress' });

    const validation = await validateDADestination(org, repo, baseFolder);
    if (!validation.valid) {
      result.errors.push(validation.error);
      result.steps[0].status = 'failed';
      result.steps[0].errors = [validation.error];
      return result;
    }

    const { source, metadata } = await resolveBlockSource(args);
    result.steps[0].status = 'completed';
    result.steps[0].source = metadata;

    result.steps.push({ step: 2, action: `Checking if block '${blockName}' exists in source`, status: 'in_progress' });

    const blockFiles = await checkBlockFiles(source, blockName);
    if (blockFiles.length === 0) {
      result.errors.push(`Block '${blockName}' not found or has no .js/.css files`);
      result.steps[1].status = 'failed';
      result.steps[1].error = 'Block not found';
      return result;
    }
    result.steps[1].status = 'completed';
    result.steps[1].exists = true;
    result.steps[1].files = blockFiles;

    const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
    const docUrl = buildContentUrl(org, repo, docPath);

    result.steps.push({ step: 3, action: 'Checking if block documentation exists', status: 'in_progress' });
    const docExists = await checkDocExists(org, repo, docPath);
    result.steps[2].status = 'completed';
    result.steps[2].exists = docExists;
    result.steps[2].path = docPath;
    result.steps[2].url = docUrl;

    if (preview) {
      result.steps.push({
        step: 4,
        action: docExists ? 'Would preserve existing documentation' : 'Would create documentation',
        status: 'planned',
        docPath,
        docUrl,
        sourceDocument: sourceDocument || null
      });

      result.steps.push({
        step: 5,
        action: 'Would add block to blocks.json',
        status: 'planned',
        configPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder)
      });

      result.steps.push({
        step: 6,
        action: 'Would register in site config library sheet',
        status: 'planned',
        libraryType: 'Blocks'
      });

      return result;
    }

    const docStep = await processBlockDocumentation(
      source, org, repo, blockName, baseFolder, description, sources, docExists, preview
    );
    result.steps.push(docStep);

    result.steps.push({ step: 5, action: 'Adding block to blocks.json', status: 'in_progress' });

    const entry = createBlockEntry(blockName, baseFolder, org, repo);
    const configResult = await updateBlocksConfig(org, repo, baseFolder, [entry]);

    result.steps[4].status = 'completed';
    result.steps[4].configPath = configResult.configPath;
    result.steps[4].optionsPreserved = configResult.optionsPreserved;
    result.steps[4].entry = entry;

    result.steps.push({ step: 6, action: 'Registering in site config library sheet', status: 'in_progress' });

    const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
    const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);

    result.steps[5].status = 'completed';
    result.steps[5].registered = regResult.registered;
    result.steps[5].librarySheet = {
      existed: !regResult.createdSheet,
      entryCount: regResult.libraryEntryCount
    };

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

async function processBlock(source, org, repo, blockName, baseFolder, sourceDocuments, autoGenerateDocs, preserveExisting, preview) {
  const blockResult = {
    name: blockName,
    action: 'unknown',
    docPath: null,
    docUrl: null,
    error: null
  };

  const blockFiles = await checkBlockFiles(source, blockName);

  if (blockFiles.length === 0) {
    blockResult.action = 'skipped';
    blockResult.error = 'No .js or .css files found';
    return blockResult;
  }

  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = buildContentUrl(org, repo, docPath);

  blockResult.docPath = docPath;
  blockResult.docUrl = docUrl;

  const docExists = await checkDocExists(org, repo, docPath);

  if (docExists && preserveExisting) {
    blockResult.action = 'preserved';
  } else if (autoGenerateDocs) {
    if (preview) {
      blockResult.action = docExists ? 'would_update' : 'would_create';
    } else {
      const analysis = await analyzeBlock(source, blockName);
      const { content: blockContent, sourceUsed } = await extractBlockContent(org, repo, sourceDocuments, blockName);
      await createBlockDoc(org, repo, docPath, blockName, analysis.variants, analysis.description, blockContent);
      blockResult.action = docExists ? 'updated' : 'created';
      blockResult.usedSourceContent = !!blockContent;
      blockResult.sourceUsed = sourceUsed || null;
    }
  } else {
    blockResult.action = 'skipped';
  }

  return blockResult;
}

async function setup(args) {
  const { org, repo, baseFolder, filter, sourceDocuments, autoGenerateDocs, preserveExisting, preview } = args;
  const sources = normalizeSourceDocuments(sourceDocuments);

  const result = {
    baseFolder,
    sourceDocuments: sources || null,
    preview,
    summary: {
      totalBlocks: 0,
      docsCreated: 0,
      docsUpdated: 0,
      docsPreserved: 0,
      docsSkipped: 0,
      configUpdated: false
    },
    blocks: [],
    errors: []
  };

  try {
    const validation = await validateDADestination(org, repo, baseFolder);
    if (!validation.valid) {
      result.errors.push(validation.error);
      return result;
    }

    const { source, metadata } = await resolveBlockSource(args);
    result.source = metadata;

    let directories = await source.listDirectories();

    if (filter) {
      const filterRegex = new RegExp(filter);
      directories = directories.filter(dir => filterRegex.test(dir.name));
    }

    result.summary.totalBlocks = directories.length;

    for (const dir of directories) {
      try {
        const blockResult = await processBlock(
          source, org, repo, dir.name, baseFolder, sources,
          autoGenerateDocs, preserveExisting, preview
        );

        if (blockResult.action === 'created') {
          result.summary.docsCreated++;
        } else if (blockResult.action === 'updated') {
          result.summary.docsUpdated++;
        } else if (blockResult.action === 'preserved') {
          result.summary.docsPreserved++;
        } else if (blockResult.action === 'skipped') {
          result.summary.docsSkipped++;
        }

        result.blocks.push(blockResult);

      } catch (error) {
        result.blocks.push({
          name: dir.name,
          action: 'error',
          docPath: null,
          docUrl: null,
          error: error.message
        });
        result.errors.push(`Block ${dir.name}: ${error.message}`);
      }
    }

    if (!preview) {
      const entries = result.blocks
        .filter(block => block.action === 'created' || block.action === 'updated' || block.action === 'preserved')
        .map(block => createBlockEntry(block.name, baseFolder, org, repo));

      if (entries.length > 0) {
        const configResult = await updateBlocksConfig(org, repo, baseFolder, entries);
        result.summary.configUpdated = true;
        result.configPath = configResult.configPath;

        const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
        const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);
        result.siteConfigRegistered = regResult.registered;
        result.librarySheet = {
          existed: !regResult.createdSheet,
          entryCount: regResult.libraryEntryCount
        };
      }
    }

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

export const tools = [
  {
    name: 'da_library_add_block',
    description: 'Add a single block to the library. AUTO-DETECTS local blocks if available. Complete workflow: validates access, creates documentation if needed, and updates blocks.json. Use preview=true to see what would be done.',
    schema: AddBlockSchema,
    handler: async (args) => addBlock(args)
  },
  {
    name: 'da_library_setup',
    description: 'Batch setup entire library. AUTO-DETECTS and prefers LOCAL blocks from ./blocks folder if available. If not found or explicitly requested, fetches from GitHub. Creates documentation, and updates blocks.json. Use preview=true to see what would be done.',
    schema: SetupSchema,
    handler: async (args) => setup(args)
  }
];
